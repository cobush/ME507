<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Final Project: Queue&lt; dataType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Final Project
   </div>
   <div id="projectbrief">This projects goal is to balance a cube on its edge using a reaction wheel. We employed code developed by users on Github to access the IMU and set up the PID controller. All references to source code are in main.cpp. See report for task and state diagrams for fully functioning balancing cube.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Queue&lt; dataType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements a queue to transmit data from one RTOS task to another.  
 <a href="class_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Queue&lt; dataType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_queue.png" usemap="#Queue_3C_20dataType_20_3E_map" alt=""/>
  <map id="Queue_3C_20dataType_20_3E_map" name="Queue_3C_20dataType_20_3E_map">
<area href="class_base_share.html" title="Base class for classes that share data in a thread-safe manner between tasks." alt="BaseShare" shape="rect" coords="0,0,126,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4a3fd660457ea5f5a4f3605322db150"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ae4a3fd660457ea5f5a4f3605322db150">Queue</a> (BaseType_t queue_size, const char *p_name=NULL, TickType_t=portMAX_DELAY)</td></tr>
<tr class="memdesc:ae4a3fd660457ea5f5a4f3605322db150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a queue object, allocating memory for the buffer.  <a href="class_queue.html#ae4a3fd660457ea5f5a4f3605322db150">More...</a><br /></td></tr>
<tr class="separator:ae4a3fd660457ea5f5a4f3605322db150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0667e09529d356a04f1efde346af266"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#aa0667e09529d356a04f1efde346af266">put</a> (const dataType &amp;item)</td></tr>
<tr class="memdesc:aa0667e09529d356a04f1efde346af266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the queue behind other items.  <a href="class_queue.html#aa0667e09529d356a04f1efde346af266">More...</a><br /></td></tr>
<tr class="separator:aa0667e09529d356a04f1efde346af266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c966c6f5f91ccaf12bcb7723b8145af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a9c966c6f5f91ccaf12bcb7723b8145af">ISR_put</a> (const dataType &amp;item)</td></tr>
<tr class="memdesc:a9c966c6f5f91ccaf12bcb7723b8145af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the queue from within an ISR.  <a href="class_queue.html#a9c966c6f5f91ccaf12bcb7723b8145af">More...</a><br /></td></tr>
<tr class="separator:a9c966c6f5f91ccaf12bcb7723b8145af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255eb8557d8106fa5900c6e4a5483ce3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a255eb8557d8106fa5900c6e4a5483ce3">butt_in</a> (const dataType &amp;item)</td></tr>
<tr class="memdesc:a255eb8557d8106fa5900c6e4a5483ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the front of the queue to be retrieved first.  <a href="class_queue.html#a255eb8557d8106fa5900c6e4a5483ce3">More...</a><br /></td></tr>
<tr class="separator:a255eb8557d8106fa5900c6e4a5483ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24849f96865b52468bcd611ee67bd7dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a24849f96865b52468bcd611ee67bd7dc">ISR_butt_in</a> (const dataType &amp;item)</td></tr>
<tr class="memdesc:a24849f96865b52468bcd611ee67bd7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the front of the queue from within an ISR.  <a href="class_queue.html#a24849f96865b52468bcd611ee67bd7dc">More...</a><br /></td></tr>
<tr class="separator:a24849f96865b52468bcd611ee67bd7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b240bc3f080ea3656d0847b5d291095"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a7b240bc3f080ea3656d0847b5d291095">is_empty</a> (void)</td></tr>
<tr class="memdesc:a7b240bc3f080ea3656d0847b5d291095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue is empty.  <a href="class_queue.html#a7b240bc3f080ea3656d0847b5d291095">More...</a><br /></td></tr>
<tr class="separator:a7b240bc3f080ea3656d0847b5d291095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d4a3d7feae804dea7f3cc72f21c624"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ac0d4a3d7feae804dea7f3cc72f21c624">ISR_is_empty</a> (void)</td></tr>
<tr class="memdesc:ac0d4a3d7feae804dea7f3cc72f21c624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue is empty, from within an ISR.  <a href="class_queue.html#ac0d4a3d7feae804dea7f3cc72f21c624">More...</a><br /></td></tr>
<tr class="separator:ac0d4a3d7feae804dea7f3cc72f21c624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14df528749e226183df3fa5472368e82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a14df528749e226183df3fa5472368e82">get</a> (dataType &amp;recv_item)</td></tr>
<tr class="memdesc:a14df528749e226183df3fa5472368e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the item at the head of the queue.  <a href="class_queue.html#a14df528749e226183df3fa5472368e82">More...</a><br /></td></tr>
<tr class="separator:a14df528749e226183df3fa5472368e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd37b4f184be25ecebf7957900321bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#afd37b4f184be25ecebf7957900321bbf">ISR_get</a> (dataType &amp;recv_item)</td></tr>
<tr class="memdesc:afd37b4f184be25ecebf7957900321bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the item at the head of the queue from within an ISR.  <a href="class_queue.html#afd37b4f184be25ecebf7957900321bbf">More...</a><br /></td></tr>
<tr class="separator:afd37b4f184be25ecebf7957900321bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44557ed37c98580b87d0196908330bcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a44557ed37c98580b87d0196908330bcc">peek</a> (dataType &amp;recv_item)</td></tr>
<tr class="memdesc:a44557ed37c98580b87d0196908330bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the item at the queue head without removing it.  <a href="class_queue.html#a44557ed37c98580b87d0196908330bcc">More...</a><br /></td></tr>
<tr class="separator:a44557ed37c98580b87d0196908330bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087ad13824fab4dfa026ef5cf138ca05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a087ad13824fab4dfa026ef5cf138ca05">ISR_peek</a> (dataType &amp;recv_item)</td></tr>
<tr class="memdesc:a087ad13824fab4dfa026ef5cf138ca05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the item at the front of the queue without deleting it, from within an ISR.  <a href="class_queue.html#a087ad13824fab4dfa026ef5cf138ca05">More...</a><br /></td></tr>
<tr class="separator:a087ad13824fab4dfa026ef5cf138ca05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb3e7ac6e9a1ec956a11cbdc7c5a44d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a7eb3e7ac6e9a1ec956a11cbdc7c5a44d">any</a> (void)</td></tr>
<tr class="memdesc:a7eb3e7ac6e9a1ec956a11cbdc7c5a44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue has contents which can be read.  <a href="class_queue.html#a7eb3e7ac6e9a1ec956a11cbdc7c5a44d">More...</a><br /></td></tr>
<tr class="separator:a7eb3e7ac6e9a1ec956a11cbdc7c5a44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80711abebd086d5617e5c88dbd87b77a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a80711abebd086d5617e5c88dbd87b77a">ISR_any</a> (void)</td></tr>
<tr class="memdesc:a80711abebd086d5617e5c88dbd87b77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue has items in it, from within an ISR.  <a href="class_queue.html#a80711abebd086d5617e5c88dbd87b77a">More...</a><br /></td></tr>
<tr class="separator:a80711abebd086d5617e5c88dbd87b77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bef71a925790602cef9eb6274ae61e3"><td class="memItemLeft" align="right" valign="top">unsigned portBASE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a6bef71a925790602cef9eb6274ae61e3">available</a> (void)</td></tr>
<tr class="memdesc:a6bef71a925790602cef9eb6274ae61e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items in the queue.  <a href="class_queue.html#a6bef71a925790602cef9eb6274ae61e3">More...</a><br /></td></tr>
<tr class="separator:a6bef71a925790602cef9eb6274ae61e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acce9f67b2549a17a8419536aac396b"><td class="memItemLeft" align="right" valign="top">unsigned portBASE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a1acce9f67b2549a17a8419536aac396b">ISR_available</a> (void)</td></tr>
<tr class="memdesc:a1acce9f67b2549a17a8419536aac396b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items in the queue, to an ISR.  <a href="class_queue.html#a1acce9f67b2549a17a8419536aac396b">More...</a><br /></td></tr>
<tr class="separator:a1acce9f67b2549a17a8419536aac396b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8d2d512e49f018c5e2df4b5a2bf810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ace8d2d512e49f018c5e2df4b5a2bf810">print_in_list</a> (Print &amp;print_dev)</td></tr>
<tr class="memdesc:ace8d2d512e49f018c5e2df4b5a2bf810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the queue's status to a serial device.  <a href="class_queue.html#ace8d2d512e49f018c5e2df4b5a2bf810">More...</a><br /></td></tr>
<tr class="separator:ace8d2d512e49f018c5e2df4b5a2bf810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5a7d38f857999a1c4cebe31089b0f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a2f5a7d38f857999a1c4cebe31089b0f7">usable</a> (void)</td></tr>
<tr class="memdesc:a2f5a7d38f857999a1c4cebe31089b0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this queue is usable.  <a href="class_queue.html#a2f5a7d38f857999a1c4cebe31089b0f7">More...</a><br /></td></tr>
<tr class="separator:a2f5a7d38f857999a1c4cebe31089b0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab009e50722f689c48d146125f6d50519"><td class="memItemLeft" align="right" valign="top">QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ab009e50722f689c48d146125f6d50519">get_handle</a> (void)</td></tr>
<tr class="memdesc:ab009e50722f689c48d146125f6d50519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle to the FreeRTOS structure which runs this queue.  <a href="class_queue.html#ab009e50722f689c48d146125f6d50519">More...</a><br /></td></tr>
<tr class="separator:ab009e50722f689c48d146125f6d50519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_base_share"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_base_share')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_base_share.html">BaseShare</a></td></tr>
<tr class="memitem:a73741a4ad0b9b54f6f6da20855c2e30b inherit pub_methods_class_base_share"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#a73741a4ad0b9b54f6f6da20855c2e30b">BaseShare</a> (const char *p_name=NULL)</td></tr>
<tr class="memdesc:a73741a4ad0b9b54f6f6da20855c2e30b inherit pub_methods_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base shared data item.  <a href="class_base_share.html#a73741a4ad0b9b54f6f6da20855c2e30b">More...</a><br /></td></tr>
<tr class="separator:a73741a4ad0b9b54f6f6da20855c2e30b inherit pub_methods_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a69b90b10718e9469499375c61cc9c236"><td class="memItemLeft" align="right" valign="top">QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a></td></tr>
<tr class="memdesc:a69b90b10718e9469499375c61cc9c236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hhandle for the FreeTOS queue.  <a href="class_queue.html#a69b90b10718e9469499375c61cc9c236">More...</a><br /></td></tr>
<tr class="separator:a69b90b10718e9469499375c61cc9c236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7869eacf6bc024b4d8ce25496fdaaed"><td class="memItemLeft" align="right" valign="top">TickType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ac7869eacf6bc024b4d8ce25496fdaaed">ticks_to_wait</a></td></tr>
<tr class="memdesc:ac7869eacf6bc024b4d8ce25496fdaaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTOS ticks to wait for empty.  <a href="class_queue.html#ac7869eacf6bc024b4d8ce25496fdaaed">More...</a><br /></td></tr>
<tr class="separator:ac7869eacf6bc024b4d8ce25496fdaaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ede016bcaf8f330cd87f56a600218b1"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a2ede016bcaf8f330cd87f56a600218b1">buf_size</a></td></tr>
<tr class="memdesc:a2ede016bcaf8f330cd87f56a600218b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of queue buffer in bytes.  <a href="class_queue.html#a2ede016bcaf8f330cd87f56a600218b1">More...</a><br /></td></tr>
<tr class="separator:a2ede016bcaf8f330cd87f56a600218b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5a036b50ef0fc8f1e587bb7307cee4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#acd5a036b50ef0fc8f1e587bb7307cee4">max_full</a></td></tr>
<tr class="memdesc:acd5a036b50ef0fc8f1e587bb7307cee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of bytes in queue.  <a href="class_queue.html#acd5a036b50ef0fc8f1e587bb7307cee4">More...</a><br /></td></tr>
<tr class="separator:acd5a036b50ef0fc8f1e587bb7307cee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_base_share"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_base_share')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_base_share.html">BaseShare</a></td></tr>
<tr class="memitem:abc438f82d56097f13a1e791dcd617a72 inherit pro_attribs_class_base_share"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#abc438f82d56097f13a1e791dcd617a72">name</a> [16]</td></tr>
<tr class="memdesc:abc438f82d56097f13a1e791dcd617a72 inherit pro_attribs_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the shared item.  <a href="class_base_share.html#abc438f82d56097f13a1e791dcd617a72">More...</a><br /></td></tr>
<tr class="separator:abc438f82d56097f13a1e791dcd617a72 inherit pro_attribs_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8077022ea40c4ba44a6ff07ab24cac83 inherit pro_attribs_class_base_share"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_base_share.html">BaseShare</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#a8077022ea40c4ba44a6ff07ab24cac83">p_next</a></td></tr>
<tr class="memdesc:a8077022ea40c4ba44a6ff07ab24cac83 inherit pro_attribs_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the next item in the linked list of shares.  <a href="class_base_share.html#a8077022ea40c4ba44a6ff07ab24cac83">More...</a><br /></td></tr>
<tr class="separator:a8077022ea40c4ba44a6ff07ab24cac83 inherit pro_attribs_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_attribs_class_base_share"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_class_base_share')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="class_base_share.html">BaseShare</a></td></tr>
<tr class="memitem:a0657d8a02509e79c3bb418aaa9cce33c inherit pro_static_attribs_class_base_share"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_base_share.html">BaseShare</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#a0657d8a02509e79c3bb418aaa9cce33c">p_newest</a> = NULL</td></tr>
<tr class="memdesc:a0657d8a02509e79c3bb418aaa9cce33c inherit pro_static_attribs_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the most recently created shared data item.  <a href="class_base_share.html#a0657d8a02509e79c3bb418aaa9cce33c">More...</a><br /></td></tr>
<tr class="separator:a0657d8a02509e79c3bb418aaa9cce33c inherit pro_static_attribs_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class dataType&gt;<br />
class Queue&lt; dataType &gt;</h3>

<p>Implements a queue to transmit data from one RTOS task to another. </p>
<p>Since multithreaded tasks must not use unprotected shared data items for communication, queues are a primary means of intertask communication. Other means include shared data items (see <code><a class="el" href="taskshare_8h.html" title="Data which can be shared between tasks in a thread-safe manner.">taskshare.h</a></code>) and carrier pigeons. The use of a C++ class template allows the compiler to check that you're putting the correct type of data into each queue and getting the correct type of data out, thus helping to prevent programming mistakes that can corrupt your data.</p>
<p>As a template class, <code>Queue&lt;dataType&gt;</code> can be used to make queues which hold data of many types. "Plain Old Data" types such as <code>bool</code> or <code>uint16_t</code> are supported, of course. But you can also use queues which hold compound data types. For example, if you have <code>class</code> <code>my_data</code> which holds several measurements together in an object, you can make a queue for <code>my_data</code> objects with <code>Queue&lt;my_data&gt;</code>. Each item in the queue will then hold several measurements.</p>
<p>The size of FreeRTOS queues is limited to 255 items in 8-bit microcontrollers whose <code>portBASE_TYPE</code> is an 8-bit number. This is a FreeRTOS feature.</p>
<p>Normal writing and reading are done with methods <code><a class="el" href="class_queue.html#aa0667e09529d356a04f1efde346af266" title="Put an item into the queue behind other items.">put()</a></code> and <code><a class="el" href="class_queue.html#a14df528749e226183df3fa5472368e82" title="Remove the item at the head of the queue.">get()</a></code>. Normal writing means that the sending task must wait until there is empty space in the queue, and then it puts a data item into the "back" of the queue, where "back" means that the item in the back of the queue will be read after all items that were previously put into the queue have been read. Normal reading means that when an item is read from the front of the queue, it will then be removed, making space for more items at the back. This process is often used to synchronize tasks, as the reading task's <code><a class="el" href="class_queue.html#a14df528749e226183df3fa5472368e82" title="Remove the item at the head of the queue.">get()</a></code> method blocks, meaning that the reading task gets stuck waiting for an item to arrive in the queue; it won't do anything useful until new data has been read. Note that this is acceptable behavior in an RTOS because the RTOS scheduler will ensure that other tasks get to run even while the reading task is blocking itself waiting for data.</p>
<p>In some cases, one may need to use less normal reading and writing methods. Methods whose name begins with <code>ISR_</code> are to be used only within a hardware interrupt service routine. If there is a need to put data at the front of the queue instead of the back, use <code><a class="el" href="class_queue.html#a255eb8557d8106fa5900c6e4a5483ce3" title="Put an item into the front of the queue to be retrieved first.">butt_in()</a></code> instead of <code><a class="el" href="class_queue.html#aa0667e09529d356a04f1efde346af266" title="Put an item into the queue behind other items.">put()</a></code>. If one needs to read data from the queue without removing that data, the <code>look_at()</code> method allows this to be done. If something particularly unusual needs to be done with the queue, one can use the method <code><a class="el" href="class_queue.html#ab009e50722f689c48d146125f6d50519" title="Return a handle to the FreeRTOS structure which runs this queue.">get_handle()</a></code> to retrieve the handle used by the C language functions in FreeRTOS to access the <a class="el" href="class_queue.html" title="Implements a queue to transmit data from one RTOS task to another.">Queue</a> object's underlying data structure directly.</p>
<h1><a class="anchor" id="queue_usage"></a>
Usage</h1>
<p>The following bits of code show how to set up and use a queue to transfer data of type <code>int16_t</code> from one hypothetical task called <code>task_A</code> to another called <code>task_B</code>.</p>
<p>Near the top of the file which contains <code><a class="el" href="main_8cpp.html#a4fc01d736fe50cf5b977f755b675f11d" title="Function that runs once to setup the balancing cube.">setup()</a></code> we create a queue. The constructor of the <code>Queue&lt;int16_t&gt;</code> class is given the number of items in the queue (10 in this example) and an optional name for the queue: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="taskqueue_8h.html">taskqueue.h</a>&quot;</span></div>
<div class="line">...<span class="comment"></span></div>
<div class="line"><span class="comment">/// This queue holds hockey puck accelerations</span></div>
<div class="line"><span class="comment"></span>Queue&lt;int16_t&gt; hockey_queue (10, <span class="stringliteral">&quot;Puckey&quot;</span>);</div>
</div><!-- fragment --><p> In a location which is before we use the queue in any other file than the one in which the queue was created, we re-declare the queue with the keyword <code>extern</code> to make it accessible to any task within that file: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="class_queue.html">Queue&lt;int16_t&gt;</a> hockey_queue;</div>
</div><!-- fragment --><p> In the sending task, data is put into the queue: </p><div class="fragment"><div class="line">int16_t an_item = -3;                 <span class="comment">///&lt; Local acceleration data</span></div>
<div class="line"><span class="comment"></span>...</div>
<div class="line">an_item = stick_sensor.get_data (2);  <span class="comment">// Read data from sensor </span></div>
<div class="line">hockey_queue.<a class="code" href="class_queue.html#aa0667e09529d356a04f1efde346af266">put</a> (a_data_item);       <span class="comment">// Put data into queue</span></div>
</div><!-- fragment --><p> In the receiving task, data is read from the queue. In typical usage, the call to <code><a class="el" href="class_queue.html#a14df528749e226183df3fa5472368e82" title="Remove the item at the head of the queue.">get()</a></code> will block the receiving task until data has been put into the queue by the sending task: </p><div class="fragment"><div class="line">int16_t data_we_got;                  <span class="comment">///&lt; Holds received data</span></div>
<div class="line"><span class="comment"></span>...</div>
<div class="line">hockey_queue.get (data_we_got);       <span class="comment">// Get data from the queue</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00126">126</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4a3fd660457ea5f5a4f3605322db150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a3fd660457ea5f5a4f3605322db150">&#9670;&nbsp;</a></span>Queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::<a class="el" href="class_queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>queue_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>wait_time</em> = <code>portMAX_DELAY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a queue object, allocating memory for the buffer. </p>
<p>This constructor creates the FreeRTOS queue which is wrapped by the <code><a class="el" href="class_queue.html" title="Implements a queue to transmit data from one RTOS task to another.">Queue</a></code> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_size</td><td>The number of characters which can be stored in the queue </td></tr>
    <tr><td class="paramname">p_name</td><td>A name to be shown in the list of task shares (default empty String) </td></tr>
    <tr><td class="paramname">wait_time</td><td>How long, in RTOS ticks, to wait for a queue to become empty before a character can be sent. (Default: <code>portMAX_DELAY</code>, which causes the sending task to block until sending occurs.) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00302">302</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    : <a class="code" href="class_base_share.html#a73741a4ad0b9b54f6f6da20855c2e30b">BaseShare</a> (p_name)</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;{</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    <span class="comment">// Create a FreeRTOS queue object with space for the data items</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a> = xQueueCreate (queue_size, <span class="keyword">sizeof</span> (dataType));</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160; </div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    <span class="comment">// Store the wait time; it will be used when writing to the queue</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <a class="code" href="class_queue.html#ac7869eacf6bc024b4d8ce25496fdaaed">ticks_to_wait</a> = wait_time;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160; </div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="comment">// Save the buffer size</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    <a class="code" href="class_queue.html#a2ede016bcaf8f330cd87f56a600218b1">buf_size</a> = queue_size;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160; </div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <span class="comment">// We haven&#39;t stored any items in the queue yet</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <a class="code" href="class_queue.html#acd5a036b50ef0fc8f1e587bb7307cee4">max_full</a> = 0;</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7eb3e7ac6e9a1ec956a11cbdc7c5a44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb3e7ac6e9a1ec956a11cbdc7c5a44d">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::any </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue has contents which can be read. </p>
<p>This method allows one to check if the queue has any contents. It must <b>not</b> be called from within an interrupt service routine. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if there's something in the queue, <code>false</code> if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00215">215</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        {</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;            <span class="keywordflow">return</span> (uxQueueMessagesWaiting (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>) != 0);</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6bef71a925790602cef9eb6274ae61e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bef71a925790602cef9eb6274ae61e3">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned portBASE_TYPE <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of items in the queue. </p>
<p>This method returns the number of items waiting in the queue. It must <b>not</b> be called from within an interrupt service routine; the method <code>ISR_num_items_in()</code> can be called from within an ISR. </p><dl class="section return"><dt>Returns</dt><dd>The number of items in the queue </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00239">239</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        {</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            <span class="keywordflow">return</span> (uxQueueMessagesWaiting (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>));</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a255eb8557d8106fa5900c6e4a5483ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255eb8557d8106fa5900c6e4a5483ce3">&#9670;&nbsp;</a></span>butt_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::butt_in </td>
          <td>(</td>
          <td class="paramtype">const dataType &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an item into the front of the queue to be retrieved first. </p>
<p>This method puts an item into the front of the queue so that it will be received first as long as nothing else is put in front of it. This is not the normal way to put things into a queue; using <code><a class="el" href="class_queue.html#aa0667e09529d356a04f1efde346af266" title="Put an item into the queue behind other items.">put()</a></code> to put items into the back of the queue is. If you always use this method, you're making a stack rather than a queue, you weirdo. This method must <b>not</b> be used within an interrupt service routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Reference to the item which is going to be (rudely) put into the front of the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the item was successfully queued, false if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00165">165</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        {</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="keywordflow">return</span> ((<span class="keywordtype">bool</span>)(xQueueSendToFront (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>, &amp;item, <a class="code" href="class_queue.html#ac7869eacf6bc024b4d8ce25496fdaaed">ticks_to_wait</a>)));</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a14df528749e226183df3fa5472368e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14df528749e226183df3fa5472368e82">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::get </td>
          <td>(</td>
          <td class="paramtype">dataType &amp;&#160;</td>
          <td class="paramname"><em>recv_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the item at the head of the queue. </p>
<p>This method gets the item at the head of the queue and removes that item from the queue. If there's nothing in the queue, this method waits, blocking the calling task, for the number of RTOS ticks specified in the <code>wait_time</code> parameter to the queue constructor (the default is forever) or until something shows up. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recv_item</td><td>A reference to the item to be filled with data from the queue </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00330">330</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;{</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="comment">// If xQueueReceive doesn&#39;t return pdTrue, nothing was found in the queue, </span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="comment">// so no changes are made to the item</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    xQueueReceive (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>, &amp;recv_item, <a class="code" href="class_queue.html#ac7869eacf6bc024b4d8ce25496fdaaed">ticks_to_wait</a>);</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab009e50722f689c48d146125f6d50519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab009e50722f689c48d146125f6d50519">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QueueHandle_t <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::get_handle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a handle to the FreeRTOS structure which runs this queue. </p>
<p>If somebody wants to do something which FreeRTOS queues can do but this class doesn't support, a handle for the queue wrapped by this class can be used to access the queue directly. This isn't commonly done. </p><dl class="section return"><dt>Returns</dt><dd>The handle of the FreeRTOS queue which is wrapped within this C++ class </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00283">283</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        {</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b240bc3f080ea3656d0847b5d291095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b240bc3f080ea3656d0847b5d291095">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::is_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue is empty. </p>
<p>This method checks if the queue is empty. It returns <code>true</code> if there are no items in the queue and <code>false</code> if there are items. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the queue is empty, <code>false</code> if it's not empty </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00180">180</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        {</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            <span class="keywordflow">return</span> (uxQueueMessagesWaiting (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>) == 0);</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a80711abebd086d5617e5c88dbd87b77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80711abebd086d5617e5c88dbd87b77a">&#9670;&nbsp;</a></span>ISR_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_any </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue has items in it, from within an ISR. </p>
<p>This method allows one to check if the queue has any contents from within an interrupt service routine. It must <b>not</b> be called from within normal, non-ISR code. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if there's something in the queue, <code>false</code> if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00227">227</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            <span class="keywordflow">return</span> (uxQueueMessagesWaitingFromISR (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>) != 0);</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1acce9f67b2549a17a8419536aac396b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acce9f67b2549a17a8419536aac396b">&#9670;&nbsp;</a></span>ISR_available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned portBASE_TYPE <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of items in the queue, to an ISR. </p>
<p>This method returns the number of items waiting in the queue; it must be called only from within an interrupt service routine. </p><dl class="section return"><dt>Returns</dt><dd>The number of items in the queue </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00250">250</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        {</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            <span class="keywordflow">return</span> (uxQueueMessagesWaitingFromISR (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>));</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a24849f96865b52468bcd611ee67bd7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24849f96865b52468bcd611ee67bd7dc">&#9670;&nbsp;</a></span>ISR_butt_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_butt_in </td>
          <td>(</td>
          <td class="paramtype">const dataType &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an item into the front of the queue from within an ISR. </p>
<p>This method puts an item into the front of the queue from within an ISR. It must <b>not</b> be used within normal, non-ISR code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item which is going to be (rudely) put into the front of the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item was successfully queued, false if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00464">464</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;{</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    <span class="comment">// This value is set true if a context switch should occur due to this data</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <span class="keywordtype">signed</span> portBASE_TYPE shouldSwitch = pdFALSE;</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160; </div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="keywordtype">bool</span> return_value;                        <span class="comment">// Value returned from this method</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160; </div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    <span class="comment">// Call the FreeRTOS function and save its return value</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    return_value = (bool)(xQueueSendToFrontFromISR (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>, &amp;item, </div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                                                    &amp;shouldSwitch));</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160; </div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="comment">// Return the return value saved from the call to xQueueSendToBackFromISR()</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="keywordflow">return</span> (return_value);</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afd37b4f184be25ecebf7957900321bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd37b4f184be25ecebf7957900321bbf">&#9670;&nbsp;</a></span>ISR_get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_get </td>
          <td>(</td>
          <td class="paramtype">dataType &amp;&#160;</td>
          <td class="paramname"><em>recv_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the item at the head of the queue from within an ISR. </p>
<p>This method gets and returns the item at the head of the queue from within an interrupt service routine. This method must <b>not</b> be called from within normal non-ISR code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recv_item</td><td>A reference to the item to be filled with data from the queue </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00346">346</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;{</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    portBASE_TYPE task_awakened;            <span class="comment">// Checks if context switch needed</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160; </div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="comment">// If xQueueReceive doesn&#39;t return pdTrue, nothing was found in the queue,</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="comment">// so we&#39;ll return the item as created by its default constructor</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    xQueueReceiveFromISR (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>, &amp;recv_item, &amp;task_awakened);</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac0d4a3d7feae804dea7f3cc72f21c624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d4a3d7feae804dea7f3cc72f21c624">&#9670;&nbsp;</a></span>ISR_is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_is_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue is empty, from within an ISR. </p>
<p>This method checks if the queue is empty from within an interrupt service routine. It must not be used in normal non-ISR code. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the queue is empty, <code>false</code> if it's not empty </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00191">191</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            <span class="keywordflow">return</span> (uxQueueMessagesWaitingFromISR (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>) == 0);</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a087ad13824fab4dfa026ef5cf138ca05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087ad13824fab4dfa026ef5cf138ca05">&#9670;&nbsp;</a></span>ISR_peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_peek </td>
          <td>(</td>
          <td class="paramtype">dataType &amp;&#160;</td>
          <td class="paramname"><em>recv_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the item at the front of the queue without deleting it, from within an ISR. </p>
<p>This method returns the item at the head of the queue without removing that item from the queue. If there's nothing in the queue, this method returns the result of the default constructor for the data item, usually zero in the given data type. This method must <b>not</b> be called from within an interrupt service routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recv_item</td><td>A reference to the item to be filled with data from the queue </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00388">388</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;{</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    portBASE_TYPE task_awakened;             <span class="comment">// Checks if a task will wake up</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160; </div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="comment">// If xQueueReceive doesn&#39;t return pdTrue, nothing was found in the queue,</span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    <span class="comment">// so the value of recv_item is not changed</span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    xQueuePeekFromISR (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>, &amp;recv_item, &amp;task_awakened);</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c966c6f5f91ccaf12bcb7723b8145af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c966c6f5f91ccaf12bcb7723b8145af">&#9670;&nbsp;</a></span>ISR_put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_put </td>
          <td>(</td>
          <td class="paramtype">const dataType &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an item into the queue from within an ISR. </p>
<p>This method puts an item of data into the back of the queue from within an interrupt service routine. It must <b>not</b> be used within non-ISR code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Reference to the item which is going to be put into the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item was successfully queued, false if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00432">432</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;{</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    <span class="comment">// This value is set true if a context switch should occur due to this data</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="keywordtype">signed</span> portBASE_TYPE shouldSwitch = pdFALSE;</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160; </div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="keywordtype">bool</span> return_value;                      <span class="comment">// Value returned from this method</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160; </div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="comment">// Call the FreeRTOS function and save its return value</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    return_value = (bool)(xQueueSendToBackFromISR (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>, &amp;item, </div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                                                   &amp;shouldSwitch));</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160; </div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    <span class="comment">// Keep track of the maximum fillage of the queue. BUG: max_full isn&#39;t</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    <span class="comment">// thread safe (but getting max_full corrupted shouldn&#39;t cause a calamity)</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    uint16_t fillage = uxQueueMessagesWaitingFromISR (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>);</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    <span class="keywordflow">if</span> (fillage &gt; <a class="code" href="class_queue.html#acd5a036b50ef0fc8f1e587bb7307cee4">max_full</a>)</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    {</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        <a class="code" href="class_queue.html#acd5a036b50ef0fc8f1e587bb7307cee4">max_full</a> = fillage;</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    }</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160; </div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    <span class="comment">// Return the return value saved from the call to xQueueSendToBackFromISR()</span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    <span class="keywordflow">return</span> (return_value);</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a44557ed37c98580b87d0196908330bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44557ed37c98580b87d0196908330bcc">&#9670;&nbsp;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::peek </td>
          <td>(</td>
          <td class="paramtype">dataType &amp;&#160;</td>
          <td class="paramname"><em>recv_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the item at the queue head without removing it. </p>
<p>This method returns the item at the head of the queue without removing that item from the queue. If there's nothing in the queue this method waits, blocking the calling task, for for the number of RTOS ticks specified in the <code>wait_time</code> parameter to the queue constructor (the default is forever) or until something shows up. This method must <b>not</b> be called from within an interrupt service routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recv_item</td><td>A reference to the item to be filled with data from the queue </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00368">368</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;{</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="comment">// If xQueueReceive doesn&#39;t return pdTrue, nothing was found in the queue,</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="comment">// so don&#39;t change the item</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    xQueuePeek (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>, &amp;recv_item, <a class="code" href="class_queue.html#ac7869eacf6bc024b4d8ce25496fdaaed">ticks_to_wait</a>);</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ace8d2d512e49f018c5e2df4b5a2bf810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8d2d512e49f018c5e2df4b5a2bf810">&#9670;&nbsp;</a></span>print_in_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::print_in_list </td>
          <td>(</td>
          <td class="paramtype">Print &amp;&#160;</td>
          <td class="paramname"><em>print_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the queue's status to a serial device. </p>
<p>This method makes a printout of the queue's status on the given serial device, then calls this same method for the next item of thread-safe data in the linked list of items. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">print_dev</td><td>Reference to the serial device on which to print </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_base_share.html#a6f72027a717afada4679fd08d08bb4b6">BaseShare</a>.</p>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00487">487</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;{</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    <span class="comment">// Print this task&#39;s name and pad it to 16 characters</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    print_dev.printf (<span class="stringliteral">&quot;%-16squeue\t&quot;</span>, <a class="code" href="class_base_share.html#abc438f82d56097f13a1e791dcd617a72">name</a>);</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160; </div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    <span class="comment">// Print the free and total number of spaces in the queue or an error</span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    <span class="comment">// message if this queue can&#39;t be used (probably due to a memory error)</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="class_queue.html#a2f5a7d38f857999a1c4cebe31089b0f7">usable</a> ())</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    {</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        print_dev &lt;&lt; <a class="code" href="class_queue.html#acd5a036b50ef0fc8f1e587bb7307cee4">max_full</a> &lt;&lt; <span class="charliteral">&#39;/&#39;</span> &lt;&lt; <a class="code" href="class_queue.html#a2ede016bcaf8f330cd87f56a600218b1">buf_size</a> &lt;&lt; endl;</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    }</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    {</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        print_dev &lt;&lt; <span class="stringliteral">&quot;UNUSABLE&quot;</span> &lt;&lt; endl;</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    }</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160; </div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    <span class="comment">// Call the next item</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="class_base_share.html#a8077022ea40c4ba44a6ff07ab24cac83">p_next</a> != NULL)</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    {</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        <a class="code" href="class_base_share.html#a8077022ea40c4ba44a6ff07ab24cac83">p_next</a>-&gt;<a class="code" href="class_base_share.html#a6f72027a717afada4679fd08d08bb4b6">print_in_list</a> (print_dev);</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    }</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa0667e09529d356a04f1efde346af266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0667e09529d356a04f1efde346af266">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const dataType &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an item into the queue behind other items. </p>
<p>This method puts an item of data into the back of the queue, which is the normal way to put something into a queue. If you want to be rude and put an item into the front of the queue so it will be retrieved first, use <code><a class="el" href="class_queue.html#a255eb8557d8106fa5900c6e4a5483ce3" title="Put an item into the front of the queue to be retrieved first.">butt_in()</a></code> instead. <b>This method must not be used within an Interrupt Service Routine.</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Reference to the item which is going to be put into the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item was successfully queued, false if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00408">408</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;{</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <span class="keywordtype">bool</span> return_value = (bool)(xQueueSendToBack (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>, &amp;item, </div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                                                 <a class="code" href="class_queue.html#ac7869eacf6bc024b4d8ce25496fdaaed">ticks_to_wait</a>));</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160; </div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="comment">// Keep track of the maximum fillage of the queue</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    uint16_t fillage = uxQueueMessagesWaiting (<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>);</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="keywordflow">if</span> (fillage &gt; <a class="code" href="class_queue.html#acd5a036b50ef0fc8f1e587bb7307cee4">max_full</a>)</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    {</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        <a class="code" href="class_queue.html#acd5a036b50ef0fc8f1e587bb7307cee4">max_full</a> = fillage;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    }</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160; </div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="keywordflow">return</span> (return_value);</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f5a7d38f857999a1c4cebe31089b0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5a7d38f857999a1c4cebe31089b0f7">&#9670;&nbsp;</a></span>usable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::usable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this queue is usable. </p>
<p>This method returns a value which is <code>true</code> if this queue has been successfully set up and can be used. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if this queue is usable, <code>false</code> if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00269">269</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        {</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            <span class="keywordflow">return</span> (<span class="keywordtype">bool</span>)<a class="code" href="class_queue.html#a69b90b10718e9469499375c61cc9c236">handle</a>;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2ede016bcaf8f330cd87f56a600218b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ede016bcaf8f330cd87f56a600218b1">&#9670;&nbsp;</a></span>buf_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::buf_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of queue buffer in bytes. </p>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00133">133</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>

</div>
</div>
<a id="a69b90b10718e9469499375c61cc9c236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b90b10718e9469499375c61cc9c236">&#9670;&nbsp;</a></span>handle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QueueHandle_t <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::handle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hhandle for the FreeTOS queue. </p>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00131">131</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>

</div>
</div>
<a id="acd5a036b50ef0fc8f1e587bb7307cee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5a036b50ef0fc8f1e587bb7307cee4">&#9670;&nbsp;</a></span>max_full</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::max_full</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of bytes in queue. </p>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00134">134</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>

</div>
</div>
<a id="ac7869eacf6bc024b4d8ce25496fdaaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7869eacf6bc024b4d8ce25496fdaaed">&#9670;&nbsp;</a></span>ticks_to_wait</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TickType_t <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ticks_to_wait</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>RTOS ticks to wait for empty. </p>

<p class="definition">Definition at line <a class="el" href="taskqueue_8h_source.html#l00132">132</a> of file <a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="taskqueue_8h_source.html">taskqueue.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclass_queue_html_a2f5a7d38f857999a1c4cebe31089b0f7"><div class="ttname"><a href="class_queue.html#a2f5a7d38f857999a1c4cebe31089b0f7">Queue::usable</a></div><div class="ttdeci">bool usable(void)</div><div class="ttdoc">Indicates whether this queue is usable.</div><div class="ttdef"><b>Definition:</b> <a href="taskqueue_8h_source.html#l00269">taskqueue.h:269</a></div></div>
<div class="ttc" id="aclass_queue_html_aa0667e09529d356a04f1efde346af266"><div class="ttname"><a href="class_queue.html#aa0667e09529d356a04f1efde346af266">Queue::put</a></div><div class="ttdeci">bool put(const dataType &amp;item)</div><div class="ttdoc">Put an item into the queue behind other items.</div><div class="ttdef"><b>Definition:</b> <a href="taskqueue_8h_source.html#l00408">taskqueue.h:408</a></div></div>
<div class="ttc" id="aclass_queue_html_ac7869eacf6bc024b4d8ce25496fdaaed"><div class="ttname"><a href="class_queue.html#ac7869eacf6bc024b4d8ce25496fdaaed">Queue::ticks_to_wait</a></div><div class="ttdeci">TickType_t ticks_to_wait</div><div class="ttdoc">RTOS ticks to wait for empty.</div><div class="ttdef"><b>Definition:</b> <a href="taskqueue_8h_source.html#l00132">taskqueue.h:132</a></div></div>
<div class="ttc" id="aclass_queue_html_a69b90b10718e9469499375c61cc9c236"><div class="ttname"><a href="class_queue.html#a69b90b10718e9469499375c61cc9c236">Queue::handle</a></div><div class="ttdeci">QueueHandle_t handle</div><div class="ttdoc">Hhandle for the FreeTOS queue.</div><div class="ttdef"><b>Definition:</b> <a href="taskqueue_8h_source.html#l00131">taskqueue.h:131</a></div></div>
<div class="ttc" id="aclass_base_share_html_a73741a4ad0b9b54f6f6da20855c2e30b"><div class="ttname"><a href="class_base_share.html#a73741a4ad0b9b54f6f6da20855c2e30b">BaseShare::BaseShare</a></div><div class="ttdeci">BaseShare(const char *p_name=NULL)</div><div class="ttdoc">Construct a base shared data item.</div><div class="ttdef"><b>Definition:</b> <a href="baseshare_8cpp_source.html#l00046">baseshare.cpp:46</a></div></div>
<div class="ttc" id="aclass_base_share_html_a8077022ea40c4ba44a6ff07ab24cac83"><div class="ttname"><a href="class_base_share.html#a8077022ea40c4ba44a6ff07ab24cac83">BaseShare::p_next</a></div><div class="ttdeci">BaseShare * p_next</div><div class="ttdoc">Pointer to the next item in the linked list of shares.</div><div class="ttdef"><b>Definition:</b> <a href="baseshare_8h_source.html#l00062">baseshare.h:62</a></div></div>
<div class="ttc" id="aclass_queue_html_acd5a036b50ef0fc8f1e587bb7307cee4"><div class="ttname"><a href="class_queue.html#acd5a036b50ef0fc8f1e587bb7307cee4">Queue::max_full</a></div><div class="ttdeci">uint16_t max_full</div><div class="ttdoc">Maximum number of bytes in queue.</div><div class="ttdef"><b>Definition:</b> <a href="taskqueue_8h_source.html#l00134">taskqueue.h:134</a></div></div>
<div class="ttc" id="ataskqueue_8h_html"><div class="ttname"><a href="taskqueue_8h.html">taskqueue.h</a></div></div>
<div class="ttc" id="aclass_base_share_html_a6f72027a717afada4679fd08d08bb4b6"><div class="ttname"><a href="class_base_share.html#a6f72027a717afada4679fd08d08bb4b6">BaseShare::print_in_list</a></div><div class="ttdeci">virtual void print_in_list(Print &amp;printer)=0</div><div class="ttdoc">Print one shared data item within a list.</div></div>
<div class="ttc" id="aclass_queue_html"><div class="ttname"><a href="class_queue.html">Queue</a></div><div class="ttdoc">Implements a queue to transmit data from one RTOS task to another.</div><div class="ttdef"><b>Definition:</b> <a href="taskqueue_8h_source.html#l00126">taskqueue.h:127</a></div></div>
<div class="ttc" id="aclass_queue_html_a2ede016bcaf8f330cd87f56a600218b1"><div class="ttname"><a href="class_queue.html#a2ede016bcaf8f330cd87f56a600218b1">Queue::buf_size</a></div><div class="ttdeci">uint16_t buf_size</div><div class="ttdoc">Size of queue buffer in bytes.</div><div class="ttdef"><b>Definition:</b> <a href="taskqueue_8h_source.html#l00133">taskqueue.h:133</a></div></div>
<div class="ttc" id="aclass_base_share_html_abc438f82d56097f13a1e791dcd617a72"><div class="ttname"><a href="class_base_share.html#abc438f82d56097f13a1e791dcd617a72">BaseShare::name</a></div><div class="ttdeci">char name[16]</div><div class="ttdoc">The name of the shared item.</div><div class="ttdef"><b>Definition:</b> <a href="baseshare_8h_source.html#l00053">baseshare.h:53</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
